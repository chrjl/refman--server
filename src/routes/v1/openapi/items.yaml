/items:
  get:
    summary: All items in the collection, excluding trashed items.
    description: |
      Get items and join keywords.

      ```sql
      SELECT
          items.*,
          group_concat(keywords.keyword) AS keywords
      FROM
          items
          LEFT OUTER JOIN keywords
          ON items.key = keywords.item_key
      GROUP BY
          keywords.item_key;
      ```

      Without query, returns all items in collection. Supported queries:

      - `itemKeys`
        : return the requested subset of items.

        ```sql
        WHERE
            items.key IN ({...itemKey})
        ```

      - `tags`
        : return the items that match the tag search (see tag search syntax).

        - OR

          ```sql
          WHERE
              keywords.keyword IN ({...tag})
          ```

        - AND
          : first, collect the `itemKey`s that match the search.

          ```sql
          WHERE
              item_key IN (
                  SELECT
                      item_key 
                  FROM
                      keywords
                  WHERE
                      keyword IN {...tag[0]}
                  INTERSECT
                  SELECT
                      item_key 
                  FROM
                      keywords
                  WHERE
                      keyword IN {...tag[1]}
              )
          ```

      - `format`
        : returns an attachment of all data.

      ---

      > ***Note:***
      > Mixing queries of different keys is not supported. Will return an error.
    tags: ['#development[items]', feature(archive)]
    parameters:
      - in: query
        name: format
        schema:
          type: string
          enum:
            - json
            - archive
        description: |
          `json` (default) will return a JSON array of all items

          `archive` will return a `.**filetype**` archive of the collection database
          - Set the `Content-Type` header to `application/**filetype**`
          - Set the `Content-Disposition` header to set the attachment filename.
          - How is the archive created?
      - in: query
        name: itemKey
        description: Comma-separated list of item `key`s
      - in: query
        name: tag
        description: |
          Search syntax (URL-encoded search strings):

          - &#x2610;
            : `tag=foo`

          - &#x2610; OR
          : `tag=foo || bar`

          - &#x2610; AND
            : `tag=foo || bar&tag=baz`

          - &#x2610; NOT
            : `tag=-foo`
    responses:
      200:
        content:
          application/json:
            schema:
              type: array
              example: []
      400:
        description: Bad request due to invalid/unsupported query.
      404:
        description: '`ENOENT` database file (Not Found)'
  delete:
    summary: Delete multiple items (to trash).
    tags: ['#development[items]']
    description: |
      In a transaction:

      - Delete items from collection, returning item entries

        ```sql
        DELETE FROM items
        WHERE
            key IN ({itemKey[0]}, {itemKey[1]}, {itemKey[2]});
        RETURNING *;
        ```

      - Create item entries in the trash table, reusing the (autogenerated) key from the collection table.

        ```sql
        INSERT INTO trash
        VALUES
            (items[0].key, items[0].title, items[0].url, items[0].details),
            (items[1].key, items[1].title, items[1].url, items[1].details),
            (items[2].key, items[2].title, items[2].url, items[2].details);
        ```

      - Keep keywords in table to allow them to remain searchable until purged.
    parameters:
      - in: query
        name: itemKey
        description: Comma-separated list of item `key`s.
        required: true
        allowReserved: true
    responses:
      204:
        description: The items were deleted (No Content)
      400:
        description: 'No `itemKeys` were provided (Bad Request)'
  post:
    summary: Create an item
    description: |
      Preprocess request body: `const {title, url, keywords, ...details} = req.body`.

      In a transaction:
      - Insert item, returning `key`

        ```sql
        INSERT INTO
            items (title, url, details)
        VALUES
            (<title>, <url>, <details>)
        RETURNING
            key AS item_key;
        ```

      - Insert keywords

        ```
        INSERT INTO
            keywords (item_key, keyword)
        VALUES
            (<item_key>, keywords[0]),
            (<item_key>, keywords[1]),
            (<item_key>, keywords[2]);
        ```

      ---

      > **Note:**
      > The server will return an error if a `key` field is included as part of the new item. The primary `key` is intended to be autogenerated by the database and returned in the server response.
    tags: ['#development[items]']
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Item'
          examples:
            example-201:
              value:
                title: example title
                exampleField: example value
            example-400-empty:
              description: 'Request body has no data.'
              value: {}
            example-400-key:
              $ref: '#/components/examples/example-400-key'
            example-400-syntax:
              $ref: '#/components/examples/example-400-syntax'
    responses:
      201:
        description: The request completed, returning the primary key of the created item. (Created)
        content:
          application/json:
            type: object
            example:
              key: example
      400:
        description: '`ERR_INVALID_ARG_TYPE` (Bad Request)'

/items/{itemKey}:
  get:
    tags: ['#development[items]']
    summary: A specific item in the collection.
    description: |
      ```sql
      SELECT
          items.*,
          group_concat(keywords.keyword) AS keywords
      FROM
          items
          LEFT OUTER JOIN keywords
          ON items.key = keywords.item_key
      GROUP BY
          keywords.item_key
      WHERE
          item.key = {itemKey};
      ```
    parameters:
      - $ref: '#/components/parameters/itemKey'
    responses:
      200:
        content:
          application/json:
            schema:
              type: object
      404:
        description: '`ENOENT` item file (Not Found)'
  delete:
    tags: ['#development[items]']
    summary: Delete an item (to trash).
    description: |
      In a transaction:

      - Delete item from collection, returning row

        ```sql
        DELETE FROM items
        WHERE
            key = {itemKey}
        RETURNING *;
        ```

      - Create item entry in the trash table, reusing the (autogenerated) key from the collection table.

        ```sql
        INSERT INTO trash
        VALUES
            (item.key, item.title, item.url, item.details),
        ```

      - Keep keywords in table to allow them to remain searchable until purged.
    parameters:
      - $ref: '#/components/parameters/itemKey'
    responses:
      204:
        description: The item was deleted (No Content)
  put:
    summary: Full-item updating.
    description: |
      Preprocess request body: `const {title, url, keywords, ...details} = req.body`.

      In a transaction:

      - Delete the item

        ```sql
        DELETE FROM items
        WHERE key = {itemKey}
        ```

      - Insert new data, explicitly setting primary key

        ```sql
        INSERT INTO items
        VALUES
            ( {itemKey}, <title>, <url>, <details> )
        ```

      - Delete keyword entries

        ```sql
        DELETE FROM keywords
        WHERE 
          item_key = {item_key};
        ```

      - Insert keyword entries

        ```sql
        INSERT INTO
            keywords (item_key, keyword)
        VALUES
            (<item_key>, keywords[0]),
            (<item_key>, keywords[1]),
            (<item_key>, keywords[2]);
        ```

      ---

      > **Note:**
      > The server will return an error if a `key` field is included as part of the new item. Reference to the the primary key is via the `itemKey` path parameter.
    tags: ['#development[items]']
    parameters:
      - $ref: '#/components/parameters/itemKey'
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/Item'
          examples:
            example-OK:
              $ref: '#/components/schemas/Item/example'
            example-400-key:
              $ref: '#/components/examples/example-400-key'
            example-400-syntax:
              $ref: '#/components/examples/example-400-syntax'
    responses:
      204:
        description: 'The item was successfully updated (No Content)'
      400:
        description: 'Invalid type/field; unparseable JSON (Bad Request)'
      404:
        description: '`ENOENT` (Not Found)'
  patch:
    summary: Partial-item updating
    description: |
      Preprocess request body: `const {title, url, keywords, ...details} = req.body`.

      - Throw an error if attempting to update keywords.

      In a transaction:

      - If `title` or `url` fields are provided, update the `items` table.

        ```sql
        UPDATE items
        SET
            title = {title},
            url = {url}
        WHERE
            key = {itemKey}
        ```

      - If any details fields are provided, update `details` json in the `items` table.

        ```sql
        UPDATE items
        SET
            details = json_patch(details, {details})
        WHERE
            key = {itemKey}
        ```

      ---

      > **Note:**
      > The server will return an error if a `key` field is included as part of item updates. Reference to the the primary key is via the `itemKey` path parameter.

      > **Note:**
      > The server will return an error if a `keywords` field is included as part of item updates. Patch updates to keywords is performed via the `/items/{itemKey}/keywords` route.
    tags: ['#development[items]']
    parameters:
      - $ref: '#/components/parameters/itemKey'
    requestBody:
      required: true
      content:
        application/json:
          schema:
            type: object
          examples:
            example-OK:
              value:
                title: updated title
                url: updated url
                urldate: updated urldate
                newDetail: new detail field
            example-400-keywords:
              value:
                keywords:
                  - keyword1
                  - keyword2
            example-400-key:
              $ref: '#/components/examples/example-400-key'
            example-400-syntax:
              $ref: '#/components/examples/example-400-syntax'
    responses:
      204:
        description: 'The item was successfully updated (No Content)'
      400:
        description: 'Invalid type/field; unparseable JSON (Bad Request)'
      404:
        description: '`ENOENT` (Not Found)'

/items/{itemKey}/tags:
  get:
    tags: ['#development[tags]']
    summary: Keywords associated with a specific item.
    description: |
      ```sql
      SELECT
          keyword
      FROM
          keywords
      WHERE
          item_key = {itemKey};
      ```
    responses:
      200:
        description: OK
        content:
          application/json:
            schema:
              type: object
            examples:
              example:
                $ref: '#/components/examples/response-keywords'

  patch:
    tags: ['#development[tags]']
    summary: Attach keywords to an item.
    description: |
      ```sql
      INSERT OR IGNORE INTO 
          keywords (item_key, keyword)
      VALUES
          ({item_key}, {tag[0]}),
          ({item_key}, {tag[1]}),
          ({item_key}, {tag[2]});
      ```

      ---

      > **Note:**
      > To update all keywords of an item, use the `PUT /items/{itemKey}` method

      > **Note:**
      > Duplicate (`itemKey`, `keyword`) entries are avoided via the `UNIQUE INDEX` constraint.
    parameters:
      - $ref: '#/components/parameters/tag'
    responses:
      204:
        description: The items were successfully updated to reflect the new keywords. (No Response)
      400:
        description: Missing required parameter. (Bad Request)
  delete:
    tags: ['#development[tags]']
    summary: Remove reference to keywords from an item.
    description: |
      ```sql
      DELETE FROM keywords
      WHERE
          item_key = {item_key} 
          AND keyword in ({tag[0]}, {tag[1]}, {tag[2]})
      ```
    parameters:
      - $ref: '#/components/parameters/tag'
    responses:
      204:
        description: The keywords were deleted from the item. (No Response)
      400:
        description: Missing required parameter. (Bad Request)

/items/trash:
  get:
    summary: Items in the trash.
    description: |
      ```sql
      SELECT
          items.*,
          group_concat(keywords.keyword) AS keywords
      FROM
          trash
          LEFT OUTER JOIN keywords
          ON trash.key = keywords.item_key
      GROUP BY
          trash.item_key;
      ```
    tags: ['#development[trash]']
    responses:
      200:
        description: OK
        content:
          application/json:
            schema:
              type: array
              example: []
  delete:
    summary: Purge items from the trash, along with their corresponding keywords entries.
    description: |
      In a transaction:

      - Delete trash items, returning keys. Default behavior is purge all items from trash.

        ```sql
        DELETE FROM trash
        RETURNING key AS purged_key;
        ```

        If a list of `itemKey`s is provided as a query parameter, only those items will be purged.

        ```sql
        WHERE key IN {...itemKey};
        ```

      - Delete keyword entries

        ```
        DELETE FROM keywords
        WHERE
            item_key IN purged_key;
        ```

    tags: ['#development[trash]']
    parameters:
      - in: query
        name: itemKey
        required: false
        schema:
          type: string
        description: Comma-separated list of item `keys`.
    responses:
      204:
        description: The items were purged from trash. (No Response)
      400:
        description: Missing required parameters. (Bad Request)
