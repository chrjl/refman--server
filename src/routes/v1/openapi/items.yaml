/items:
  get:
    summary: All items in the collection, excluding trashed items.
    description: |
      Get item and join keywords:

      ```sql
      SELECT
          items.*,
          group_concat(keywords.keyword) AS keywords
      FROM
          items
          LEFT OUTER JOIN keywords
          ON items.key = keywords.item_key
      GROUP BY
          keywords.item_key;
      ```
    tags: [development/items, development/archive]
    parameters:
      - in: query
        name: format
        schema:
          type: string
          enum:
            - json
            - archive
        description: |
          `json` (default) will return a JSON array of all items

          `archive` will return a `.**filetype**` archive of the collection database
          - Set the `Content-Type` header to `application/**filetype**`
          - Set the `Content-Disposition` header to set the attachment filename.
          - How is the archive created?
    responses:
      200:
        content:
          application/json:
            schema:
              type: array
      404:
        description: "`ENOENT` database file (Not Found)"
  delete:
    summary: Delete multiple items (to trash).
    tags: [development/items]
    description: |
      In a transaction:

      - Delete items from collection, returning item entries

        ```sql
        DELETE FROM items
        WHERE
            key IN (<key0>, <key1>, <key2>);
        RETURNING *;
        ```

      - Create item entries in the trash table, reusing the (autogenerated) key from the collection table.

        ```sql
        INSERT INTO trash
        VALUES
            (items[0].key, items[0].title, items[0].url, items[0].details),
            (items[1].key, items[1].title, items[1].url, items[1].details),
            (items[2].key, items[2].title, items[2].url, items[2].details);
        ```

      - Keep keywords in table to allow them to remain searchable until purged.
    parameters:
      - name: itemKey
        in: query
        description: Comma-separated list of `key`s of items to delete (to trash).
        required: true
        allowReserved: true
    responses:
      204:
        description: The items were deleted (No Content)
      400:
        description: "No `itemKeys` were provided (Bad Request)"
  post:
    summary: Create an item
    description: |
      Preprocess request body: `const {title, url, keywords, ...details} = req.body`.

      In a transaction:
      - Insert item, returning `key`

        ```sql
        INSERT INTO
            items (title, url, details)
        VALUES
            (<title>, <url>, <details>)
        RETURNING
            key AS item_key;
        ```

      - Insert keywords

        ```
        INSERT INTO
            keywords (item_key, keyword)
        VALUES
            (<item_key>, keywords[0]),
            (<item_key>, keywords[1]),
            (<item_key>, keywords[2]);
        ```

      ---

      > **Note:**
      > The server will return an error if a `key` field is included as part of the new item. The primary `key` is intended to be autogenerated by the database and returned in the server response.
    tags: [development/items]
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: "#/components/schemas/Item"
          examples:
            example-201:
              value:
                title: example title
                exampleField: example value
            example-400-empty:
              description: "Request body has no data."
              value: {}
            example-400-key:
              $ref: "#/components/examples/example-400-key"
            example-400-syntax:
              $ref: "#/components/examples/example-400-syntax"
    responses:
      201:
        description: "The request completed, returning the primary key of the created item."
        content:
          application/json:
            type: object
            example:
              key: example
      400:
        description: "`ERR_INVALID_ARG_TYPE` (Bad Request)"

/items/{itemKey}:
  get:
    tags: [development/items]
    summary: A specific item in the collection.
    description: |
      ```sql
      SELECT
          items.*,
          group_concat(keywords.keyword) AS keywords
      FROM
          items
          LEFT OUTER JOIN keywords
          ON items.key = keywords.item_key
      GROUP BY
          keywords.item_key
      WHERE
          item.key = {itemKey};
      ```
    parameters:
      - $ref: "#/components/parameters/itemKey"
    responses:
      200:
        content:
          application/json:
            schema:
              type: object
      404:
        description: "`ENOENT` item file (Not Found)"
  delete:
    tags: [development/items]
    summary: Delete an item (to trash).
    description: |
      In a transaction:

      - Delete item from collection, returning row

        ```sql
        DELETE FROM items
        WHERE
            key = {itemKey}
        RETURNING *;
        ```

      - Create item entry in the trash table, reusing the (autogenerated) key from the collection table.

        ```sql
        INSERT INTO trash
        VALUES
            (item.key, item.title, item.url, item.details),
        ```

      - Keep keywords in table to allow them to remain searchable until purged.
    parameters:
      - $ref: "#/components/parameters/itemKey"
    responses:
      204:
        description: The item was deleted (No Content)
  put:
    summary: Full-item updating.
    description: |
      Preprocess request body: `const {title, url, keywords, ...details} = req.body`.

      In a transaction:

      - Delete the item

        ```sql
        DELETE FROM items
        WHERE key = {itemKey}
        ```

      - Insert new data, explicitly setting primary key

        ```sql
        INSERT INTO items
        VALUES
            ( {itemKey}, <title>, <url>, <details> )
        ```

      - Delete keyword entries

        ```sql
        DELETE FROM keywords
        WHERE 
          item_key = {item_key};
        ```

      - Insert keyword entries

        ```sql
        INSERT INTO
            keywords (item_key, keyword)
        VALUES
            (<item_key>, keywords[0]),
            (<item_key>, keywords[1]),
            (<item_key>, keywords[2]);
        ```

      ---

      > **Note:**
      > The server will return an error if a `key` field is included as part of the new item. Reference to the the primary key is via the `itemKey` path parameter.
    tags: [development/items]
    parameters:
      - $ref: "#/components/parameters/itemKey"
    requestBody:
      required: true
      content:
        application/json:
          schema:
            $ref: "#/components/schemas/Item"
          examples:
            example-OK:
              $ref: "#/components/schemas/Item/example"
            example-400-key:
              $ref: "#/components/examples/example-400-key"
            example-400-syntax:
              $ref: "#/components/examples/example-400-syntax"
    responses:
      204:
        description: "The item was successfully updated (No Content)"
      400:
        description: "Invalid type/field; unparseable JSON (Bad Request)"
      404:
        description: "`ENOENT` (Not Found)"
  patch:
    summary: Partial-item updating
    description: |
      Preprocess request body: `const {title, url, keywords, ...details} = req.body`.
      
      - Throw an error if attempting to update keywords.

      In a transaction:
      
      - If `title` or `url` fields are provided, update the `items` table.

        ```sql
        UPDATE items
        SET
            title = {title},
            url = {url}
        WHERE
            key = {itemKey}
        ```

      - If any details fields are provided, update `details` json in the `items` table.

        ```sql
        UPDATE items
        SET
            details = json_patch(details, {details})
        WHERE
            key = {itemKey}
        ```

      ---

      > **Note:**
      > The server will return an error if a `key` field is included as part of item updates. Reference to the the primary key is via the `itemKey` path parameter.

      > **Note:**
      > The server will return an error if a `keywords` field is included as part of item updates. Patch updates to keywords is performed via the `/items/{itemKey}/keywords` route.
    tags: [development/items]
    parameters:
      - $ref: "#/components/parameters/itemKey"
    requestBody:
      required: true
      content:
        application/json:
          schema:
            type: object
          examples:
            example-OK:
              value:
                title: updated title
                url: updated url
                urldate: updated urldate
                newDetail: new detail field
            example-400-keywords:
              value:
                keywords:
                  - keyword1
                  - keyword2
            example-400-key:
              $ref: "#/components/examples/example-400-key"
            example-400-syntax:
              $ref: "#/components/examples/example-400-syntax"
    responses:
      204:
        description: "The item was successfully updated (No Content)"
      400:
        description: "Invalid type/field; unparseable JSON (Bad Request)"
      404:
        description: "`ENOENT` (Not Found)"
